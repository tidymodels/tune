% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit_best.R
\name{fit_best}
\alias{fit_best}
\alias{fit_best.default}
\alias{fit_best.tune_results}
\title{Fit a model to the numerically optimal configuration}
\usage{
fit_best(x, ...)

\method{fit_best}{default}(x, ...)

\method{fit_best}{tune_results}(x, metric = NULL, parameters = NULL, verbose = FALSE, ...)
}
\arguments{
\item{x}{The results of class \code{tune_results} (coming from functions such as
\code{\link[=tune_grid]{tune_grid()}}, \code{\link[=tune_bayes]{tune_bayes()}}, etc). The control option
\code{save_workflow = TRUE} should have been used.}

\item{...}{Not currently used.}

\item{metric}{A character string (or \code{NULL}) for which metric to optimize. If
\code{NULL}, the first metric is used.}

\item{parameters}{An optional tibble of tuning parameter settings.}
}
\value{
A fitted workflow.
}
\description{
\code{fit_best()} takes the results from model tuning and fits it to the training
set using tuning parameters associated with the best performance.
}
\details{
This function is a shortcut for the manual steps of:

\preformatted{
  best_param <- select_best(tune_results, metric) # or other `select_*()`
  wflow <- finalize_workflow(wflow, best_param)  # or just `finalize_model()`
  wflow_fit <- fit(wflow, data_set)
}

The data used for the fit are taken from the \code{splits} column. If the split
column was from a validation split, the combined training and validation sets
are used.

In comparison to \code{\link[=last_fit]{last_fit()}}, that function requires a finalized model, fits
the model on the data set by \code{\link[rsample:initial_split]{rsample::initial_split()}}, and computes
metrics from the test set.
}
\examples{
library(recipes)
library(rsample)
library(dplyr)

data(meats, package = "modeldata")
meats <- meats \%>\% select(-water, -fat)

set.seed(1)
meat_split <- initial_split(meats)
meat_train <- training(meat_split)
meat_test <- testing(meat_split)

set.seed(2)
meat_rs <- vfold_cv(meat_train, v = 10)

pca_rec <-
  recipe(protein ~ ., data = meat_train) \%>\%
  step_pca(all_predictors(), num_comp = tune())

knn_mod <- nearest_neighbor(neighbors = tune()) \%>\% set_mode("regression")

ctrl <- control_grid(save_workflow = TRUE)

knn_pca_res <-
  tune_grid(knn_mod, pca_rec, resamples = meat_rs, grid = 10, control = ctrl)

knn_fit <- fit_best(knn_pca_res, verbose = TRUE)
}
