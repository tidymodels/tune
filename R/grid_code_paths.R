tune_nothing_with_recipe <- function(resamples, grid, object, metrics, ctrl)  {
  resample_with_recipe(resamples, object, metrics, ctrl)
}

tune_nothing_with_formula <- function(resamples, grid, object, metrics, ctrl)  {
  resample_with_formula(resamples, object, metrics, ctrl)
}

# ------------------------------------------------------------------------------

iter_rec_and_mod <- function(rs_iter, resamples, grid, object, metrics, ctrl) {
  load_pkgs(object)
  load_namespace(ctrl$pkgs)
  fit_ctrl <- parsnip::fit_control(verbosity = 0, catch = TRUE)

  metric_est <- NULL
  extracted <- NULL
  pred_vals <- NULL
  .notes <- NULL

  split <- resamples$splits[[rs_iter]]

  model_param <-
    dials::parameters(object) %>%
    dplyr::filter(source == "model_spec") %>%
    dplyr::pull(id)
  rec_param <-
    dials::parameters(object) %>%
    dplyr::filter(source == "recipe") %>%
    dplyr::pull(id)

  if (tidyr_new_interface()) {
    rec_grid <- tidyr::nest(tibble::as_tibble(grid), data = dplyr::one_of(model_param))
  } else {
    rec_grid <- tidyr::nest(grid, !!!model_param)
  }

  # --------------------------------------------------------------------------

  num_rec <- nrow(rec_grid)
  for (rec_iter in 1:num_rec) {
    rec_msg <- paste0("recipe ", format(1:num_rec)[rec_iter], "/", num_rec)

    # Current recipe parameters only
    rec_grid_vals <-
      rec_grid %>%
      dplyr::slice(rec_iter) %>%
      dplyr::select(-data)
    tmp_rec <- catch_and_log(train_recipe(split, object, rec_grid_vals), ctrl, split, "recipe", notes = .notes)

    # All model tune parameters associated with the current recipe parameters
    mod_grid_vals <-
      rec_grid %>%
      dplyr::slice(rec_iter) %>%
      dplyr::select(-one_of(rec_param)) %>%
      tidyr::unnest(cols = dplyr::one_of("data"))

    # Determine the _minimal_ number of models to fit in order to get
    # predictions on all models.
    mod_grid_vals <- get_wflow_model(object) %>% min_grid(mod_grid_vals)

    # ------------------------------------------------------------------------

    num_mod <- nrow(mod_grid_vals)
    for (mod_iter in 1:num_mod) {
      mod_msg <- paste0(rec_msg, ", model ", format(1:num_mod)[mod_iter], "/", num_mod)

      fixed_param <- mod_grid_vals %>% dplyr::slice(mod_iter) %>% dplyr::select(-.submodels)
      submd_param <- mod_grid_vals %>% dplyr::slice(mod_iter) %>% dplyr::select(.submodels)
      submd_param <- submd_param$.submodels[[1]]

      tmp_fit <-
        catch_and_log(
          train_model_from_recipe(object, tmp_rec, fixed_param, control = fit_ctrl),
          ctrl,
          split,
          mod_msg,
          notes = .notes
        )

      all_param <- dplyr::bind_cols(rec_grid_vals, mod_grid_vals[mod_iter, ])

      # check for failure
      if (!inherits(tmp_fit, "try-error")) {

        tmp_pred <-
          catch_and_log(
            predict_model_from_recipe(split, tmp_fit, tmp_rec, all_param, metrics),
            ctrl,
            split,
            paste(mod_msg, "(predictions)"),
            bad_only = TRUE,
            notes = .notes
          )

        metric_est <- append_metrics(metric_est, tmp_pred, object, metrics, split)
        pred_vals <- append_predictions(pred_vals, tmp_pred, split, ctrl)

      }
      extracted <- append_extracts(extracted, tmp_rec, tmp_fit$fit, all_param, split, ctrl)
    } # end model loop

  } # end recipe loop

  list(.metrics = metric_est, .extracts = extracted, .predictions = pred_vals, .notes = .notes)
}

tune_rec_and_mod <- function(resamples, grid, object, metrics, ctrl) {
  B <- nrow(resamples)

  `%op%` <- get_operator(ctrl$allow_par, object)

  lab_names <- names(labels(resamples$splits[[1]]))

  results <-
    foreach::foreach(rs_iter = 1:B, .packages = "tune", .errorhandling = "pass") %op%
    iter_rec_and_mod(rs_iter, resamples, grid, object, metrics, ctrl)

  resamples <- pull_metrics(resamples, results, ctrl)
  resamples <- pull_notes(resamples, results, ctrl)
  resamples <- pull_extracts(resamples, results, ctrl)
  resamples <- pull_predictions(resamples, results, ctrl)

  resamples
}

# ------------------------------------------------------------------------------

iter_rec <- function(rs_iter, resamples, grid, object, metrics, ctrl) {
  load_pkgs(object)
  load_namespace(ctrl$pkgs)
  fit_ctrl <- parsnip::fit_control(verbosity = 0, catch = TRUE)

  split <- resamples$splits[[rs_iter]]
  metric_est <- NULL
  extracted <- NULL
  pred_vals <- NULL
  .notes <- NULL

  num_rec <- nrow(grid)

  for (param_iter in 1:num_rec) {
    param_vals <- grid[param_iter, ]
    rec_msg <- paste0("recipe ", format(1:num_rec)[param_iter], "/", num_rec)
    mod_msg <- paste0(rec_msg, ", model 1/1")

    tmp_rec <- catch_and_log(train_recipe(split, object, param_vals), ctrl, split, rec_msg, notes = .notes)

    tmp_fit <-
      catch_and_log(
        train_model_from_recipe(object, tmp_rec, NULL, control = fit_ctrl),
        ctrl,
        split,
        mod_msg,
        notes = .notes
      )


    # check for failure
    if (!inherits(tmp_fit$fit, "try-error")) {
      pred_msg <- paste(mod_msg, "(predictions)")
      tmp_pred <-
        catch_and_log(
          predict_model_from_recipe(split, tmp_fit, tmp_rec, param_vals, metrics),
          ctrl,
          split,
          pred_msg,
          bad_only = TRUE,
          notes = .notes
        )

      metric_est <- append_metrics(metric_est, tmp_pred, object, metrics, split)
      pred_vals <- append_predictions(pred_vals, tmp_pred, split, ctrl)

    }

    extracted <- append_extracts(extracted, tmp_rec, tmp_fit$fit, grid[param_iter, ], split, ctrl)
  } # recipe parameters

  list(.metrics = metric_est, .extracts = extracted, .predictions = pred_vals, .notes = .notes)

}

tune_rec <- function(resamples, grid, object, metrics, ctrl) {
  B <- nrow(resamples)

  `%op%` <- get_operator(ctrl$allow_par, object)

  results <-
    foreach::foreach(rs_iter = 1:B, .packages = "tune", .errorhandling = "pass") %op%
    iter_rec(rs_iter, resamples, grid, object, metrics, ctrl)

  resamples <- pull_metrics(resamples, results, ctrl)
  resamples <- pull_notes(resamples, results, ctrl)
  resamples <- pull_extracts(resamples, results, ctrl)
  resamples <- pull_predictions(resamples, results, ctrl)

  resamples
}


# ------------------------------------------------------------------------------

tune_mod_with_recipe <- function(resamples, grid, object, metrics, ctrl) {
  B <- nrow(resamples)

  `%op%` <- get_operator(ctrl$allow_par, object)

  results <-
    foreach::foreach(rs_iter = 1:B, .packages = "tune", .errorhandling = "pass") %op%
    iter_mod_with_recipe(rs_iter, resamples, grid, object, metrics, ctrl)

  resamples <- pull_metrics(resamples, results, ctrl)
  resamples <- pull_notes(resamples, results, ctrl)
  resamples <- pull_extracts(resamples, results, ctrl)
  resamples <- pull_predictions(resamples, results, ctrl)

  resamples
}

iter_mod_with_recipe <- function(rs_iter, resamples, grid, object, metrics, ctrl) {
  load_pkgs(object)
  load_namespace(ctrl$pkgs)
  fit_ctrl <- parsnip::fit_control(verbosity = 0, catch = TRUE)
  split <- resamples$splits[[rs_iter]]
  metric_est <- NULL
  extracted <- NULL
  pred_vals <- NULL
  .notes <- NULL

  # ----------------------------------------------------------------------------

  tmp_rec <-
    catch_and_log(train_recipe(split, object, NULL),
                  ctrl,
                  split,
                  "recipe",
                  notes = .notes)

  # Determine the _minimal_ number of models to fit in order to get
  # predictions on all models.
  mod_grid_vals <- get_wflow_model(object) %>% min_grid(grid)

  num_mod <- nrow(mod_grid_vals)
  for (mod_iter in 1:num_mod) {
    mod_msg <- paste0("model ", format(1:num_mod)[mod_iter], "/", num_mod)

    tmp_fit <-
      catch_and_log(
        train_model_from_recipe(object, tmp_rec, mod_grid_vals[mod_iter,], control = fit_ctrl),
        ctrl,
        split,
        mod_msg,
        notes = .notes
      )

    # check for failure
    if (!inherits(tmp_fit$fit, "try-error")) {

      tmp_pred <-
        catch_and_log(
          predict_model_from_recipe(split, tmp_fit, tmp_rec, mod_grid_vals[mod_iter,], metrics),
          ctrl,
          split,
          paste(mod_msg, "(predictions)"),
          bad_only = TRUE,
          notes = .notes
        )

      metric_est  <- append_metrics(metric_est, tmp_pred, object, metrics, split)
      pred_vals <- append_predictions(pred_vals, tmp_pred, split, ctrl)

    }

    extracted <- append_extracts(extracted, tmp_rec, tmp_fit$fit, mod_grid_vals[mod_iter, ], split, ctrl)
  } # end model loop

  list(.metrics = metric_est, .extracts = extracted, .predictions = pred_vals, .notes = .notes)

}

# ------------------------------------------------------------------------------


tune_mod_with_formula <- function(resamples, grid, object, metrics, ctrl) {
  B <- nrow(resamples)

  `%op%` <- get_operator(ctrl$allow_par, object)

  results <-
    foreach::foreach(rs_iter = 1:B, .packages = "tune", .errorhandling = "pass") %op%
    iter_mod_with_formula(rs_iter, resamples, grid, object, metrics, ctrl)

  resamples <- pull_metrics(resamples, results, ctrl)
  resamples <- pull_notes(resamples, results, ctrl)
  resamples <- pull_extracts(resamples, results, ctrl)
  resamples <- pull_predictions(resamples, results, ctrl)

  resamples
}

iter_mod_with_formula <- function(rs_iter, resamples, grid, object, metrics, ctrl) {
  load_pkgs(object)
  load_namespace(ctrl$pkgs)
  fit_ctrl <- parsnip::fit_control(verbosity = 0, catch = TRUE)
  split <- resamples$splits[[rs_iter]]
  metric_est <- NULL
  extracted <- NULL
  pred_vals <- NULL
  .notes <- NULL

  # ----------------------------------------------------------------------------

  tmp_df <- catch_and_log(exec_formula(split, object), ctrl, split, "formula", notes = .notes)
  tmp_trms <- tmp_df$terms
  tmp_df <- tmp_df[c("x", "y")]

  # Determine the _minimal_ number of models to fit in order to get
  # predictions on all models.
  mod_grid_vals <- get_wflow_model(object) %>% min_grid(grid)

  num_mod <- nrow(mod_grid_vals)
  for (mod_iter in 1:num_mod) {
    param_val <- mod_grid_vals[mod_iter, ]
    mod_msg <- paste0("model ", format(1:num_mod)[mod_iter], "/", num_mod)

    tmp_fit <-
      catch_and_log(
        train_model_from_df(object, tmp_df, param_val, control = fit_ctrl),
        ctrl,
        split,
        mod_msg,
        notes = .notes
      )

    # check for failure
    if (!inherits(tmp_fit$fit, "try-error")) {

      pred_msg <- paste(mod_msg, "(predictions)")

      tmp_pred <-
        catch_and_log(
          predict_model_from_terms(split, tmp_fit, tmp_trms, param_val, metrics),
          ctrl,
          split,
          mod_msg,
          notes = .notes
        )

      metric_est  <- append_metrics(metric_est, tmp_pred, object, metrics, split)
      pred_vals <- append_predictions(pred_vals, tmp_pred, split, ctrl)

    }

    extracted <- append_extracts(extracted, NULL, tmp_fit$fit, param_val, split, ctrl)
  } # end model loop

  list(.metrics = metric_est, .extracts = extracted, .predictions = pred_vals, .notes = .notes)

}

